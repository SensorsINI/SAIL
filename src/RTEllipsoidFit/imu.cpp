#include "ros/ros.h"
#include "std_msgs/String.h"
#include "std_msgs/Float64MultiArray.h"

#include <sstream>
#include "RTIMULib.h"


int main(int argc, char **argv)
{

	/*
	*for initializing and setting up ROS
	*/
	ros::init(argc, argv, "imu");
	ros::NodeHandle n;
	ros::Publisher pose = n.advertise<std_msgs::String>("pose", 1000);
	ros::Publisher acceleration = n.advertise<std_msgs::Float64MultiArray>("acceleration", 1000);
	ros::Publisher compass = n.advertise<std_msgs::Float64MultiArray>("compass", 1000);
	ros::Rate loop_rate(10);

	/*
	*for IMU
	*/

	int sampleCount = 0;
    	int sampleRate = 0;
    	uint64_t rateTimer;
    	uint64_t displayTimer;
    	uint64_t now;

	//  Using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.
    	//  Or, you can create the .ini in some other directory by using:
    	//      RTIMUSettings *settings = new RTIMUSettings("<directory path>", "RTIMULib");
    	//  where <directory path> is the path to where the .ini file is to be loaded/saved


	RTIMUSettings *settings = new RTIMUSettings("RTIMULib");

    	RTIMU *imu = RTIMU::createIMU(settings);

    	if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        	ROS_WARN("No IMU found\n");
        	exit(1);
    	}

	//  This is an opportunity to manually override any settings before the call IMUInit

    	//  set up IMU

    	imu->IMUInit();

	//  this is a convenient place to change fusion parameters

    	imu->setSlerpPower(0.02);
    	imu->setGyroEnable(true);
    	imu->setAccelEnable(true);
    	imu->setCompassEnable(true);

    	//  set up for rate timer

    	rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();

	std_msgs::String pose_data;
	std_msgs::Float64MultiArray acceleration_data;
	std_msgs::Float64MultiArray compass_data;

	while (ros::ok())
	{

		//  poll at the rate recommended by the IMU

        	usleep(imu->IMUGetPollInterval() * 1000);

        	while (imu->IMURead()) {
            		RTIMU_DATA imuData = imu->getIMUData();
            		sampleCount++;
 
            		now = RTMath::currentUSecsSinceEpoch();

            		//  display 10 times per second

            		if ((now - displayTimer) > 100000) {

                		ROS_DEBUG("Sample rate %d\n", sampleRate); //Sample rate
                		ROS_DEBUG("Pose: %s\n", RTMath::displayDegrees("", imuData.fusionPose)); //pose
                		ROS_DEBUG("Acceleration: %f, %f, %f\n", imuData.accel.x(), imuData.accel.y(), imuData.accel.z()); //acceleration
                		ROS_DEBUG("Compass: %f, %f, %f\r", imuData.compass.x(), imuData.compass.y(), imuData.compass.z()); //compass
				//ROS_INFO("Pose from accel and mag: %s\n", RTMath::displayDegrees("", RTMath::poseFromAccelMag(imuData.accel,imuData.compass)));

				pose_data.data=RTMath::displayDegrees("",imuData.fusionPose);
				acceleration_data.data={imuData.accel.x(),imuData.accel.y(),imuData.accel.z()};
				compass_data.data={imuData.compass.x(), imuData.compass.y(), imuData.compass.z()};

				pose.publish(pose_data);
				acceleration.publish(acceleration_data);
				compass.publish(compass_data);

                		displayTimer = now;
            		}

            		//  update rate every second

            		if ((now - rateTimer) > 1000000) {
                		sampleRate = sampleCount;
                		sampleCount = 0;
                		rateTimer = now;
            		}
		}
		//std_msgs::String msg;

   		//std::stringstream ss;
    		//ss << "hello world " << count;
    		//msg.data = ss.str();

    		//ROS_INFO("%s", msg.data.c_str());
		//chatter_pub.publish(msg);

    		ros::spinOnce();

    		loop_rate.sleep();
	}
	return 0;
}
